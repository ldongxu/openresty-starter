  map $http_upgrade $connection_upgrade {
       default upgrade;
       ''      close;
     }

    server {
        listen 80;
        listen   443  ssl so_keepalive=on;
        server_name  localhost;
    include ssl.conf;
    lua_check_client_abort on;

    underscores_in_headers on;
    proxy_connect_timeout 6s;
    proxy_send_timeout   10s;
    proxy_read_timeout   10s;
     resolver 172.22.1.253 172.22.1.254;
    #resolver 10.42.0.231 10.42.0.237;
    #resolver 10.10.10.10 10.10.10.20;
    # proxy_next_upstream error timeout invalid_header http_502;
    proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        #access_log  logs/host.access.log  main;
        error_log  logs/log_80.log notice;

        location / {
            root   html;
            index  index.html index.htm;
        }

        location /test {
             default_type text/plain;
                        content_by_lua_block {

                           local acclist = require("httpacclist")

                            ngx.print(string.format([[{"code" : 200, "msg" : "OK", "data": {"whitelist": %s }}]], acclist:get_acclist_str()))

                        }
        }

        location /test_html {
            content_by_lua_block {
                local p = ngx.var.arg_a
                if p == "1" then
                ngx.log(ngx.ERR,"param :",p)
                    ngx.exec("/no_permission")
                    return
                end
                 local d = require("httpacclist"):get_acclist()
                 ngx.log(ngx.NOTICE, d .. ", worker "..ngx.worker.id().. ", ".. ngx.worker.pid())
                 ngx.say(d .. ", worker "..ngx.worker.id().. ", ".. ngx.worker.pid())
                 return
            }
        }

        location /no_permission {
                internal;
                default_type text/html;
                alias ./html/nopermission.html;
        }

         location /sse_html {
                  default_type text/html;
                  alias ./html/sse.html;
         }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
        location  ~* ^/wsproxy/([^/]+)/(.*)$
        {

             set $target_host $1;
             set $url_full  $2;
             rewrite .* /$url_full break;
             proxy_pass  http://$target_host;

             proxy_connect_timeout 600s;
             proxy_read_timeout 600s;

             proxy_http_version 1.1;
             proxy_buffering  off;
             #proxy_pass_request_headers on;
             proxy_pass_header Authorization;
             # proxy_set_header Authorization $http_authorization;
             proxy_set_header Upgrade  $http_upgrade;
             proxy_set_header Connection  $connection_upgrade;
             proxy_set_header Host  $host;
             proxy_set_header Cookie $http_cookie;
             proxy_set_header X-Real-IP  $remote_addr;
             proxy_set_header X-Forwarded-for  $remote_addr;
             #delete ws-protocol-header for ws backend.
             proxy_set_header sec-websocket-protocol "";

        }

        location /ws {
         proxy_pass http://localhost:8080/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }

        location /sse {
            proxy_pass http://localhost:8080/events;
        }


        location ~ /ssev2/([^/]+) {
            set $eventid $1;
            content_by_lua_file lua/ssehandle.lua;
        }

        location  /proxy
        {
        if ($http_x_logid = "")
        {
            set_by_lua $reqid '
                local mill = tonumber(ngx.var.msec)*1000
                local rdnum = math.random(100000,999999)
                return mill..rdnum
           ';
            set $http_x_logid $reqid;
        }
            include mime.types;
            set $b_scheme $scheme;
            set $b_host $http_host;
            set $b_uri  $uri;

            rewrite_by_lua_file   lua/proxy_rewrite.lua;
            content_by_lua_file   lua/forward.lua;
        }

        location =  /forward
        {
            internal;
            more_clear_input_headers Accept-Encoding;
            #proxy_pass_request_headers to off;
            set_by_lua  $target_scheme  ' return ngx.unescape_uri(ngx.var.arg_target_scheme);' ;
            set_by_lua  $target_host    ' return ngx.unescape_uri(ngx.var.arg_target_host);' ;
            set_by_lua  $target_url     ' return ngx.unescape_uri(ngx.var.arg_target_url);' ;
            rewrite_by_lua_block
            {
                ngx.log(ngx.NOTICE, "/forward:bscheme=",ngx.var.target_scheme,
                        ",bsvr=",ngx.var.target_host, ",burl=",ngx.var.target_url, ",method=", ngx.req.get_method()," ,body=",ngx.req.get_body_data())
            }

            proxy_hide_header "If-None-Match";
            # proxy_redirect ~*^/(.+)$  $target_scheme://$target_host/$1;

            proxy_set_header Host $target_host;
            proxy_set_header X-Real-IP $remote_addr;
            # proxy_set_header X-Forwarded-For  $http_x_forwarded_for;
            proxy_set_header    X-Forwarded-Port   "";
            proxy_pass $target_scheme://$target_host$target_url;
        }


    }